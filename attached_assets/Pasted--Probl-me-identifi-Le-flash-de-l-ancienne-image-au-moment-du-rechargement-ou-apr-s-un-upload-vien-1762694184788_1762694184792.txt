ğŸ’¬ ProblÃ¨me identifiÃ©
Le flash de lâ€™ancienne image au moment du rechargement ou aprÃ¨s un upload vient du comportement par dÃ©faut de React Query (TanStack). Lorsquâ€™on invalide une query avec queryClient.invalidateQueries(), React Query affiche immÃ©diatement la donnÃ©e en cache (stale) pendant quâ€™il refait le fetch en arriÃ¨re-plan.
RÃ©sultat : pendant quelques millisecondes, le composant <img> reÃ§oit encore le src avec lâ€™ancienne version (ex : ?v=1), puis se met Ã  jour vers la nouvelle (?v=2). Câ€™est ce bref dÃ©calage qui provoque le flash visuel.

âš™ï¸ Diagnostic technique


invalidateQueries() ne remplace pas la donnÃ©e, il dÃ©clenche simplement un refetch asynchrone.


React Query applique une stratÃ©gie stale-while-revalidate, donc lâ€™ancienne donnÃ©e reste affichÃ©e le temps que la nouvelle soit reÃ§ue.


Comme la banniÃ¨re est une image (chargÃ©e par le navigateur indÃ©pendamment du cycle React), le rendu de lâ€™ancienne persiste visuellement, mÃªme si le cache est remplacÃ© ensuite.



âœ… Solution technique recommandÃ©e
La solution consiste Ã  mettre Ã  jour immÃ©diatement le cache React Query aprÃ¨s lâ€™upload â€” avant mÃªme que le refetch nâ€™ait lieu.
En clair : dÃ¨s que le serveur retourne { imageUrl, version } aprÃ¨s lâ€™upload, on pousse cette nouvelle valeur directement dans le cache via queryClient.setQueryData().
Exemple :
const mutation = useMutation({
  mutationFn: uploadBanner,
  onSuccess: (data) => {
    // data = { imageUrl, version }
    queryClient.setQueryData(["/api/banners", pageKey], data);

    // (Optionnel) puis dÃ©clencher un refetch en arriÃ¨re-plan
    queryClient.invalidateQueries(["/api/banners", pageKey]);
  },
});

Pourquoi Ã§a fonctionne :


setQueryData met instantanÃ©ment Ã  jour le cache pour la clÃ© ['/api/banners', pageKey].


Le hook useQuery utilisÃ© dans useBannerImage renverra donc immÃ©diatement la nouvelle URL (${imageUrl}?v=${version}) au lieu de lâ€™ancienne.


Aucun Â« flash Â» nâ€™a lieu, puisque React ne rÃ©affiche plus la donnÃ©e stale.


Ensuite, lâ€™invalidation dÃ©clenche un refetch silencieux pour sâ€™assurer que les donnÃ©es serveur sont bien alignÃ©es, mais sans impacter lâ€™UI.



âœ¨ Option dâ€™amÃ©lioration UX
Pour une transition parfaite (zÃ©ro flicker mÃªme en cas de latence rÃ©seau), tu peux prÃ©charger la nouvelle image avant de mettre Ã  jour le cache.
Exemple :
const handleUploadSuccess = (data) => {
  const img = new Image();
  img.onload = () => {
    queryClient.setQueryData(["/api/banners", pageKey], data);
  };
  img.src = `${data.imageUrl}?v=${data.version}`;
};

De cette maniÃ¨re, React Query ne bascule sur la nouvelle image quâ€™une fois quâ€™elle est prÃªte Ã  Ãªtre affichÃ©e.

ğŸš€ TL;DR


Le flash vient du mode stale-while-revalidate de React Query.


Il ne faut pas se contenter dâ€™un invalidateQueries.


La solution propre : mettre Ã  jour le cache avec setQueryData dans onSuccess du useMutation.


Bonus : prÃ©charger la nouvelle image avant de remplacer le cache.


Ce pattern est parfaitement alignÃ© avec la doc TanStack et Ã©limine le flash sans introduire de state local ni casser la logique de cache-busting par version.