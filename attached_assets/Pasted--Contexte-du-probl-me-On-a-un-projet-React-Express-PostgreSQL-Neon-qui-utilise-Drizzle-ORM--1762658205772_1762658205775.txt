ğŸ’¡ Contexte du problÃ¨me

On a un projet React + Express + PostgreSQL (Neon) qui utilise Drizzle ORM v0.44.7 et drizzle-kit v0.31.4, avec un dÃ©ploiement entiÃ¨rement automatisÃ© sur Render.
Localement, la commande npm run db:push fonctionne parfaitement et crÃ©e toutes les tables dÃ©finies dans shared/schema.ts.
Mais sur Render, deux tables rÃ©cemment ajoutÃ©es â€” banner_images et push_subscriptions â€” ne sont jamais crÃ©Ã©es, bien que drizzle-kit push --force soit exÃ©cutÃ© sans aucune erreur.

Les logs Render montrent uniquement :

NeonDbError: relation "banner_images" does not exist
NeonDbError: relation "push_subscriptions" does not exist


Les autres tables (parent_requests, nanny_applications, etc.) sont bien prÃ©sentes et fonctionnelles.

ğŸ§© Analyse technique du problÃ¨me

Ce comportement est typique dâ€™un dÃ©ploiement serverless CI/CD oÃ¹ drizzle-kit push sâ€™exÃ©cute dans un environnement oÃ¹ le schÃ©ma TypeScript nâ€™est pas accessible au moment de la commande.
Sur Render, au moment du npm run start, seul le dossier dist/ est garanti, et Drizzle ne â€œvoitâ€ donc plus le shared/schema.ts.

RÃ©sultat :

drizzle-kit push tourne sans planter, mais ne dÃ©tecte aucun changement.

Les tables manquantes ne sont jamais crÃ©Ã©es.

Comme aucun SQL nâ€™est gÃ©nÃ©rÃ©, Render dÃ©marre sur une base incomplÃ¨te.

Autres causes possibles Ã  vÃ©rifier :

Chemin du schÃ©ma Drizzle mal rÃ©solu dans drizzle.config.ts â†’ Drizzle ne lit pas les nouvelles tables.

Exports manquants dans shared/schema.ts (Drizzle ignore les const non exportÃ©s).

Connexion poolÃ©e Neon (PgBouncer) utilisÃ©e au lieu de la connexion directe. Neon bloque parfois la crÃ©ation de tables via le pool (problÃ¨me connu).

ExÃ©cution au mauvais moment dans le pipeline Render : drizzle-kit push pourrait sâ€™exÃ©cuter avant que le code ne soit Ã  jour.

âœ… Axes de solution Ã  tester
1. Passer de push Ã  generate + migrate

Remplacer dans package.json :

"scripts": {
  "start": "npm run db:migrate && NODE_ENV=production node dist/index.js",
  "db:migrate": "drizzle-kit migrate --config=drizzle.config.ts"
}


et exÃ©cuter au build :

drizzle-kit generate --config=drizzle.config.ts


â¡ï¸ generate crÃ©e les fichiers SQL dans /migrations, et migrate les applique.
Câ€™est la maniÃ¨re â€œproduction safeâ€ de Drizzle (idempotente, traÃ§able et compatible Render).

2. Sâ€™assurer que le schÃ©ma est lisible en production

Dans drizzle.config.ts :

export default {
  dialect: "postgresql",
  schema: "./shared/schema.ts",
  out: "./migrations",
  dbCredentials: { url: process.env.DATABASE_URL },
};


Et dans package.json â†’ modifier la commande de build :

"build": "tsc && cp -r shared dist/"


ğŸ‘‰ Ainsi, Render embarque shared/schema.ts dans dist/, et Drizzle le verra.

3. VÃ©rifier le type de connexion Neon

Ne pas utiliser la connexion poolÃ©e (PgBouncer) pour les migrations.
Drizzle doit pointer vers lâ€™URL directe (port 5432).
Si Render utilise le port 6543, remplacer DATABASE_URL par la version â€œdirect connectâ€ de Neon.

4. Ajouter une commande Pre-Deploy sur Render

Dans la config Render :

Pre-deploy command: npm run db:migrate
Start command: NODE_ENV=production node dist/index.js


De cette faÃ§on, les migrations seront toujours exÃ©cutÃ©es juste avant la mise en ligne.

5. Option fallback â€” Migration programmatique

CrÃ©er un script server/migrate.ts :

import { migrate } from "drizzle-orm/neon-http/migrator";
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);

(async () => {
  await migrate(db, { migrationsFolder: "./migrations" });
  console.log("âœ… Migrations appliquÃ©es");
})();


Et lâ€™exÃ©cuter dans Render :

npx ts-node server/migrate.ts


Cela garantit que les tables sont crÃ©Ã©es mÃªme si Drizzle CLI Ã©choue.

ğŸ’¬ Recommandation personnelle

Je te conseille de remplacer dÃ©finitivement drizzle-kit push par migrate,
de copier le schÃ©ma dans dist/ pendant le build,
et de lancer npm run db:migrate en pre-deploy.

Câ€™est la mÃ©thode la plus stable avec Render + Neon.
Elle fonctionne mÃªme si Drizzle CLI ne dÃ©tecte plus les fichiers TypeScript compilÃ©s.

Si tu veux un diagnostic plus fin, lance drizzle-kit push --verbose pour vÃ©rifier si Drizzle dÃ©tecte bien les deux tables dans le schÃ©ma.
Sâ€™il ne les log pas, câ€™est que schema.ts nâ€™est pas trouvÃ© au moment du build.